package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

const usage = `usage: gqlclientgen -s <schema> -o <output> [options...]

Generate Go types and helpers for the specified GraphQL schema.

Options:

  -s <schema>   GraphQL schema, can be specified multiple times. Required.
  -o <output>   Output filename for generated Go code. Required.
  -n <package>  Go package name, defaults to "main".
`

type stringSliceFlag []string

func (v *stringSliceFlag) String() string {
	return fmt.Sprint([]string(*v))
}

func (v *stringSliceFlag) Set(s string) error {
	*v = append(*v, s)
	return nil
}

func genType(schema *ast.Schema, t *ast.Type) *jen.Statement {
	if t.Elem != nil {
		return jen.Index().Add(genType(schema, t.Elem))
	}

	def := schema.Types[t.NamedType]

	if !t.NonNull {
		switch def.Name {
		case "ID", "Time", "Map", "Any":
			// These don't need a pointer
		default:
			cpy := *t
			cpy.NonNull = true
			return jen.Op("*").Add(genType(schema, &cpy))
		}
	}

	switch def.Name {
	// Standard types
	case "Int":
		return jen.Int32()
	case "Float":
		return jen.Float64()
	case "String":
		return jen.String()
	case "Boolean":
		return jen.Bool()
	case "ID":
		return jen.String()
	// Convenience types
	case "Time":
		return jen.Qual("time", "Time")
	case "Map":
		return jen.Map(jen.String()).Interface()
	case "Upload":
		return jen.Qual("git.sr.ht/~emersion/gqlclient", "Upload")
	case "Any":
		return jen.Interface()
	default:
		if def.BuiltIn {
			panic(fmt.Sprintf("unsupported built-in type: %s", def.Name))
		}
		return jen.Id(def.Name)
	}
}

func genDef(schema *ast.Schema, def *ast.Definition) *jen.Statement {
	switch def.Kind {
	case ast.Scalar:
		switch def.Name {
		case "Time", "Map", "Upload", "Any":
			// Convenience types
			return nil
		default:
			return jen.Type().Id(def.Name).String()
		}
	case ast.Enum:
		var defs []jen.Code
		for _, val := range def.EnumValues {
			nameWords := strings.Split(strings.ToLower(val.Name), "_")
			for i := range nameWords {
				nameWords[i] = strings.Title(nameWords[i])
			}
			name := strings.Join(nameWords, "")
			defs = append(defs, jen.Id(def.Name+name).Id(def.Name).Op("=").Lit(val.Name))
		}
		return jen.Add(
			jen.Type().Id(def.Name).String(),
			jen.Line(),
			jen.Const().Defs(defs...),
		)
	case ast.Object, ast.Interface:
		var fields []jen.Code
		for _, field := range def.Fields {
			if field.Name == "__schema" || field.Name == "__type" {
				continue // TODO
			}
			name := strings.Title(field.Name)
			fields = append(fields, jen.Id(name).Add(genType(schema, field.Type)))
		}
		return jen.Type().Id(def.Name).Struct(fields...)
	default:
		panic(fmt.Sprintf("unsupported definition kind: %s", def.Kind))
	}
}

func main() {
	var schemaFilenames []string
	var pkgName, outputFilename string
	flag.Var((*stringSliceFlag)(&schemaFilenames), "s", "schema filename")
	flag.StringVar(&pkgName, "n", "main", "package name")
	flag.StringVar(&outputFilename, "o", "", "output filename")
	flag.Usage = func() {
		fmt.Println(usage)
	}
	flag.Parse()

	if len(schemaFilenames) == 0 || outputFilename == "" || len(flag.Args()) > 0 {
		flag.Usage()
		os.Exit(1)
	}

	var sources []*ast.Source
	for _, filename := range schemaFilenames {
		b, err := os.ReadFile(filename)
		if err != nil {
			log.Fatalf("failed to load schema %q: %v", filename, err)
		}
		sources = append(sources, &ast.Source{Name: filename, Input: string(b)})
	}

	schema, gqlErr := gqlparser.LoadSchema(sources...)
	if gqlErr != nil {
		log.Fatalf("failed to parse schema: %v", gqlErr)
	}

	f := jen.NewFile(pkgName)
	f.HeaderComment("Code generated by gqlclientgen - DO NOT EDIT")

	var typeNames []string
	for _, def := range schema.Types {
		if def.BuiltIn || def == schema.Query || def == schema.Mutation || def == schema.Subscription {
			continue
		}
		typeNames = append(typeNames, def.Name)
	}

	sort.Strings(typeNames)

	for _, name := range typeNames {
		stmt := genDef(schema, schema.Types[name])
		if stmt != nil {
			f.Add(stmt).Line()
		}
	}

	if err := f.Save(outputFilename); err != nil {
		log.Fatalf("failed to save output file: %v", err)
	}
}
